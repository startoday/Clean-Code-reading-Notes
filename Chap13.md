### 并发编程 Concurrency

    “Objects are abstractions of processing. Threads are abstractions of schedule.”
  
1. Why Concurrency？
    Decoupling what from when can dramatically improve both the throughput and structures of an application. 
    
    • Concurrency incurs some overhead, both in performance as well as writing additional code.

    • Correct concurrency is complex, even for simple problems.

    • Concurrency bugs aren’t usually repeatable, so they are often ignored as one-offs instead of the true defects they are.

    • Concurrency often requires a fundamental change in design strategy.
    
2. Challenges
    For a simple function:

       public class X {
          private int lastIdUsed;
          public int getNextId() {
               return ++lastIdUsed;
           }
       }
       
    How many different paths are there? To really answer that question, we need to understand what the Just-In-Time Compiler does with the generated byte-code, and understand what the Java memory model considers to be atomic.
   
3. CONCURRENCY DEFENSE PRINCIPLES
    - SRP: **Recommendation**: Keep your concurrency-related code separate from other code.
    - Limit the Scope of Data: One solution is to use the synchronized keyword to protect a critical section in the code that uses the shared object. 
            **Recommendation**: Take data encapsulation to heart; severely limit the access of any data that may be shared.
    - Use Copies of Data: if using copies of objects allows the code to avoid synchronizing, the savings in avoiding the intrinsic lock will likely make up for the additional creation and garbage collection overhead.
    - Threads Should Be as Independent as Possible: **Recommendation**: Attempt to partition data into independent subsets than can be operated on by independent threads, possibly in different processors.
    
4. KNOW YOUR LIBRARY

    • Use the provided thread-safe collections.

    • Use the executor framework for executing unrelated tasks.

    • Use nonblocking solutions when possible.

    • Several library classes are not thread safe.
    
    be familiar with java.util.concurrent, java.util.concurrent.atomic, java.util.concurrent.locks.
    
  
5. KNOW YOUR EXECUTION MODELS

    - Producer-Consumer: The queue between the producers and consumers is a bound resource. （限定资源：并发环境中有固定尺寸或数量的资源）
    
    - Readers-Writers： When you have a shared resource that primarily serves as a source of information for readers, but which is occasionally updated by writers, throughput is an issue.
  

6. BEWARE DEPENDENCIES BETWEEN SYNCHRONIZED METHODS
    
    **Recommendation**: Avoid using more than one method on a shared object.
    when there has to be, here are three ways to make code correct:
    
    • *Client-Based Locking*—Have the client lock the server before calling the first method and make sure the lock’s extent includes code calling the last method.

    • *Server-Based Locking*—Within the server create a method that locks the server, calls all the methods, and then unlocks. Have the client call the new method.

    • *Adapted Server*—create an intermediary that performs the locking. This is an example of server-based locking, where the original server cannot be changed.
   
7. KEEP SYNCHRONIZED SECTIONS SMALL
    
    Locks are expensive
    **Recommendation**: Keep your synchronized sections as small as possible.
    
8. WRITING CORRECT SHUT-DOWN CODE IS HARD
   - whend dead lock happens, the system can wait forever, or a system that has been instructed to shut down, may also cause a problem.
   - **Recommendation**: Think about shut-down early and get it working early. It’s going to take longer than you expect. Review existing algorithms because this is probably harder than you think.
   
9. TESTING THREADED CODE
    That is a whole lot to take into consideration. Here are a few more fine-grained recommendations:

    • Treat spurious failures as candidate threading issues. **Recommendation: Do not ignore system failures as one-offs. 别把系统的错误归咎于偶发事件**  

    • Get your nonthreaded code working first. **Recommendation**: Do not try to chase down nonthreading bugs and threading bugs at the same time. Make sure your code works outside of threads.

    • Make your threaded code pluggable. **Recommendation**: Make your thread-based code especially pluggable so that you can run it in various configurations

    • Make your threaded code tunable.

    • Run with more threads than processors.   Explain：Things happen when the system switches between tasks. To encourage task swapping, run with more threads than processors or cores. The more frequently your tasks swap, the more likely you’ll encounter code that is missing a critical section or causes deadlock.

    • Run on different platforms.

    • Instrument your code to try and force failures.
        - How might you increase your chances of catching such rare occurrences? You can instrument your code and force it to run in different orderings by adding calls to methods like Object.wait(), Object.sleep(), Object.yield() and Object.priority().
            Use stuff like this and Now you use a simple aspect that randomly selects among doing nothing, sleeping, or yielding :
            
               public class ThreadJigglePoint {
                   public static void jiggle() {
                   }
               }
               
              //  Call the upper method in various places within your code to test 
              public synchronized String nextUrlOrNull() {
                   if(hasNext()) {
                       ThreadJiglePoint.jiggle();
                       String url = urlGenerator.next();
                       ThreadJiglePoint.jiggle();
                       updateHasNext();
                       ThreadJiglePoint.jiggle();
                       return url;
                   } 
                   return null;
               }
